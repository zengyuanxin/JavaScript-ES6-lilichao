一. JavaScript基础

### 1.数据类型

#### 1.1 数值（Number）

* 在JS中所有的整数和浮点数都是Number类型
* JS中的数值并不是无限大的，当数值超过一定范围后会显示近似值
* **Infinity 是一个特殊的数值表示无穷 **
* 所以在JS中进行一些精度比较高的运算时要十分注意
* **NaN 也是一个特殊的数值，表示非法的数值**

```javascript
let a = 10
a = 10.5
a = Infinity
a = 1.11111111111111111111111111111111111111111111
a = 0.0000000000000000000000000000000000001
a = 0.1 + 0.2
a = 1 - "a" // NaN (Not a Number)
a = NaN
```

#### 1.2 大整数（BigInt） 

* 大整数用来表示一些比较大的整数 
* **大整数使用n结尾**，它可以表示的数字范围是无限大 

`a = 99999999999999999999999999999999999999999999999999n `

### 2. 字符串（String）

* 模板字符串
  * **使用反单引号` 来表示模板字符串**
  * 模板字符串中可以嵌入变量
  * 使用typeof检查一个字符串时会返回 "string"

```javascript
            let name = "猪八戒"

            let str = `你好，${name}`
```

### 3. 流程控制

#### 3.1 代码块

* 使用 {} 来创建代码块，**代码块可以用来对代码进行分组**
  * 同一个代码中的代码，就是同一组代码，一个代码块中的代码**要么都执行要么都不执行**
* **let 和 var**
  *  **在JS中，使用let声明的变量具有块作用域**
  * 在代码块中声明的变量无法在代码块的外部访问
  * **使用var声明的变量，不具有块作用域**

```javascript
{
	var a = 10
}
console.log(a)
```

![1662806701188](C:\Users\79426\AppData\Local\Temp\1662806701188.png)



### 4. 对象

#### 4.1 对象的属性

*  属性名 
  * 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求，但是如果你的**属性名太特殊**了，不能直接使用，**需要使用[]来设置**，虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名
  * 也可以使用**符号（symbol）**作为属性名，来添加属性，获取这种属性时，也必须使用symbol，**使用symbol添加的属性，通常是那些不希望被外界访问的属性**
  * **使用[]去操作属性时，可以使用变量** 
* 属性值 
  * 对象的属性值可以是任意的数据类型，也可以是一个对象 
* 使用typeof检查一个对象时，会返回object 



#### 4.2 对象字面量

* 对象字面量 
  * 可以直接使用{} 来创建对象 
  * 使用{}所创建的对象，可以直接向对象中添加属性 

语法：

​	{

​		属性名：属性值

​		[属性名]：属性值

​	}

```javascript
let mySymbol = Symbol()

        let obj2 = {
            name:"孙悟空", 
            age:18,
            ["gender"]:"男",
            [mySymbol]:"特殊的属性",
            hello:{
                a:1,
                b:true
            }
        }
```



#### 4.3 枚举属性

* 枚举属性，指将对象中的所有的属性全部获取 

##### for-in语句

语法：

​	**for(let propName in 对象)**{

​		语句...

​	}

* for-in的循环体会执行多次，有几个属性就会执行几次，每次执行时，都会将一个属性名赋值给我们所定义的变量
* 注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性 

```javascript
        let obj = {
            name:'孙悟空',
            age:18,
            gender:"男",
            address:"花果山",
            [Symbol()]:"测试的属性" // 符号添加的属性是不能枚举
        }

        for(let propName in obj){
            console.log(propName, obj[propName])
        }
```



#### 4.4 可变类型

*  原始值都属于不可变类型，一旦创建就无法修改
* 在内存中不会创建重复的原始值

```js
		let a = 10 
        let b = 10
        a = 12 
	// 当我们为一个变量重新赋值时，绝对不会影响其他变量
```

>  - 对象属于可变类型
>  - 对象创建完成后，可以任意的添加删除修改对象中的属性
>  - 注意：
>      - 当对两个对象进行相等或全等比较时，比较的是对象的内存地址
>      - 如果有两个变量同时指向一个对象，
>          通过一个变量修改对象时，对另外一个变量也会产生影响



#### 4.5 改变量和改对象

> **修改对象**
>
> - 修改对象时，如果有其他变量指向该对象,则所有指向该对象的变量都会受到影响
>   - a.name = "Tom"
>   - a = {}
>
> **修改变量**
>
> * 修改变量时，只会影响当前的变量
>   * a = 10
>
> >在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度

> **所以通常情况下，声明存储对象的变量时会使用const**
>
> **注意：**
>  	**const只是禁止变量被重新赋值，对对象的修改没有任何影响** 

```js
			const obj = {
                name: "孙悟空",
            }
```



#### 4.5 方法（method） 

* 方法（method）
  * 当一个对象的属性指向一个函数
  * 那么我们就称这个函数是该对象的方法
  * 调用函数就称为调用对象的方法

```js
        let obj = {}

        obj.name = "孙悟空"
        obj.age = 18

        // 函数也可以成为一个对象的属性
        obj.sayHello = function(){
            alert("hello")
        }

        console.log(obj)

        obj.sayHello()
```



### 5.函数

#### 5.1 函数

* 函数（Function）

  *  函数也是一个对象
  * 它具有其他对象所有的功能
  * 函数中可以存储代码，且可以在需要时调用这些代码

* 语法： 

  function 函数名(){

  ​	语句...

  }

* 调用函数： 

  * 调用函数就是执行函数中存储的代码 

  * 语法：

    ​	函数对象()

* 使用typeof检查函数对象时会返回function 

```js
// 创建一个函数对象
        function fn(){
            console.log("萨瓦迪卡")
            console.log("阿尼哈撒有")
        }

        console.log(typeof fn)
```



#### 5.2 函数的创建方式

*  函数的定义方式： 

  * 1.函数声明 

    ```JS
    function 函数名(){
    
    	语句...
    
    }
        
    function fn(){
    	console.log("函数声明所定义的函数~")
    }
    ```

  * 2.函数表达式 

    ```JS
    const 变量 = function(){
    	语句...
    }
            
    const fn2 = function(){
        console.log("函数表达式")
    }
    ```

  * 3.箭头函数 

    ```JS
    () => {
    	语句...
    	}
        
    const fn3 = () => {
        console.log("箭头函数")
    }
    
    const fn4 = () => console.log("箭头函数")
    ```



#### 5.3 参数

* 形式参数

  *  在定义函数时，可以在函数中指定数量不等的形式参数（形参）
  * 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

* 实际参数

  * 在调用函数时，可以在函数的()传递数量不等的实参

  *  实参会赋值给其对应的形参

    *  参数：

      	1.  如果实参和形参数量相同，则对应的实参赋值给对应的形参

                      2.  如果**实参多于形参**，则**多余的实参不会使用**

                      3. 如果**形参多于实参**，则**多余的形参为undefined**

    * 参数的类型：

      ​	JS中不会检查参数的类型，可以传递任何类型的值作为参数

```js
1.函数声明
        function 函数名([参数]){
            语句...
        }
2.函数表达式
    const 变量 = function([参数]){
        语句...
    }
3.箭头函数
    ([参数]) => {
        语句...
    }
```

##### 5.3.1 箭头函数的参数

```js
<script>
    const fn = (a, b) => {
        console.log("a =", a);
        console.log("b =", b);
    }
    // 当箭头函数中只有一个参数时，可以省略()
	//const fn2 = (a) => {
    const fn2 = a => {
        console.log("a =", a);
    }
    // fn2(123)
    // 定义参数时，可以为参数指定默认值
    // 默认值，会在没有对应实参时生效
    const fn3 = (a=10, b=20, c=30) => {
        console.log("a =", a);
        console.log("b =", b);
        console.log("c =", c);
    }
    fn3(1, 2)
</script>
```

##### 5.3.2 对象作为参数

```js
原始代码 1 ：
		// 3. 执行函数        
		function fn(a){
            console.log("a =", a)
            // a = {name : 孙悟空}
            console.log(a.name)
            // 孙悟空
            
        }
        // 1. 对象可以作为参数传递
        let obj = {name:"孙悟空"}

        // 2. 传递实参时，传递并不是变量本身，而是变量中存储的值
        // 相当于将 name:"孙悟空" ——> fn(name:"孙悟空")
        fn(obj)
```

![1662885629980](C:\Users\79426\AppData\Local\Temp\1662885629980.png)

```js
问题 1 ：形参和实参指向同一个对象，在函数里修改对象
		function fn(a){
            a.name = "猪八戒"
            // 修改对象时，如果有其他变量指向该对象则所有指向该对象的变量都会受到影响
            // 注意： 此时 obj 和 a 指向同一个对象
            console.log(a)
        }
        let obj = {name:"孙悟空"}
        fn(obj)

		console.log(obj)//结果是多少？
```

![1662885472099](C:\Users\79426\AppData\Local\Temp\1662885472099.png)

```js
问题 2 ： 形参和实参指向不同对象，在函数里修改对象
		function fn(a){
            a = {} 
            // 将新对象赋值给变量a，a指向的是一个新的对象
            // 修改变量时，只会影响当前的变量
            a.name = "猪八戒"
            // 注意： 此时 obj 和 a 指向不同对象
            console.log(a)
        }
        let obj = {name:"孙悟空"}
        fn(obj)

		console.log(obj)//结果是多少？
```

![1662886049445](C:\Users\79426\AppData\Local\Temp\1662886049445.png)

```js
原始代码 2 ：
		// 3. 执行函数        
		function fn(a){
            a.name = "猪八戒"
            console.log(a)
        }
        let obj = {name:"孙悟空"}
        fn(obj)
        function fn2(a = 1){
            console.log("a =", a)
        }

        fn2() //a = 1
```

```js
问题 1 ：给 a 的默认值传一个对象
		function fn2(a = {name:"沙和尚"}){
            console.log("a =", a)
            a.name = "唐僧"
            console.log("a =", a)
        }

        fn2() // 沙和尚 唐僧
```

![1662886556547](C:\Users\79426\AppData\Local\Temp\1662886556547.png)

```js
问题 2 ：打印两次 fn2() ，看两次调用的默认对象是否是同一个对象
		function fn2(a = {name:"沙和尚"}){
            console.log("a =", a)
            a.name = "唐僧"
            console.log("a =", a)
        }

        fn2() // 沙和尚 唐僧
		fn2() // 沙和尚 唐僧 or 唐僧 唐僧 ？
```

![1662886764920](C:\Users\79426\AppData\Local\Temp\1662886764920.png)

**说明：两次调用的默认对象不是同一个对象，函数每次调用，都会重新创建默认值** 

```js
问题 3 ：在外面创建对象再调用
		let obj2 = {name:"沙和尚"}
        
        function fn2(a = obj2){
            console.log("a =", a)
            a.name = "唐僧"
            console.log("a =", a)
        }

        fn2() // 沙和尚 唐僧
        fn2() // 唐僧 唐僧
```

![1662886941139](C:\Users\79426\AppData\Local\Temp\1662886941139.png)

**说明：**

​	**如果是直接将字面量写在形参位置，那么每次都会创建一个新对象，每次改都是独立的**

​	**如果是在外面创建的对象，形参 = 外面创建的对象，那么每次调用都是共用一个对象**

##### 5.3.3 函数作为参数

```js
 		function fn(a){
            console.log("a =", a)
            // a()
        }

        /* 
            在JS中，函数也是一个对象（一等函数）
                别的对象能做的事情，函数也可以
        */

        let obj = {name:"孙悟空"}
        fn(obj)// a = {name : 孙悟空}
```

```js
		function fn2(){
            console.log("我是fn2")
        }

        fn(fn2)
		// a 指向 fn2 ，把函数作为参数传递给另一个函数
```

![1662887884717](C:\Users\79426\AppData\Local\Temp\1662887884717.png)

```js
在函数里直接调另一个传入的函数
		function fn(a){
             a()
        }
        function fn2(){
            console.log("我是fn2")
        }

        fn(fn2)
		//我是fn2
```

```js
在函数里创建匿名函数、箭头函数
		fn(function(){
            console.log("我是匿名函数~")
        })

        fn(()=>console.log("我是箭头函数"))
```



#### 5.4 箭头函数的返回值

* 箭头函数的返回值可以直接写在箭头后
*  如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

```js
        const sum = (a, b) => a + b

        const fn = () => ({name:"孙悟空"})

        let result = sum(123, 456)

        result = fn()

        console.log(result)
```



#### 5.5 Window 对象

* **Window对象**
  * 在浏览器中，浏览器为我们提供了一个window对象，可以直接访问
  *  **window对象代表的是浏览器窗口**，通过该对象可以对浏览器窗口进行各种操作
    * 除此之外**window对象还负责存储JS中的内置对象和浏览器的宿主对象**
  *  window对象的属性可以通过window对象访问，也可以直接访问
  * **函数就可以认为是window对象的方法**

```js
 window.a = 10 
// 向window对象中添加的属性会自动成为全局变量
```

* **var**
  * var 用来声明变量，作用和let相同，但是**var不具有块作用域**
  * *在全局中使用var声明的变量，都会作为window对象的属性保存**
  *  **使用function声明的函数，都会作为window的方法保存**
  * *使用let声明的变量不会存储在window对象中**，而存在一个秘密的小地方（无法访问）**
  * ** **var虽然没有块作用域，但有函数作用域**

```js
var b = 20 // window.b = 20
```



#### 5.6 提升

* 变量的提升
  * **使用var声明的变量，它会在所有代码执行前被声明**
  * 所以我们可以在变量声明前就访问变量
* 函数的提升
  * **使用函数声明创建的函数，会在其他代码执行前被创建**
  *  所以我们可以在函数声明前调用函数
* ***let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问***



#### 5.7 立即执行函数

**希望可以创建一个只执行一次的匿名函数** 

* 在开发中应该尽量减少直接在全局作用域中编写代码！（no var）
* 所以我们的代码要尽量编写在局部作用域（let）
* **如果使用let声明的变量，可以使用{}来创建块作用域**

```js
        {
            let a = 10
        }
```

* **立即执行函数（IIFE）**

  * **立即是一个匿名的函数，并它只会调用一次**
  * 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

* **语法：**

  **（ function{} ）（）或 （  function{}（））**

  **function开头的代码会被提升，所以需要一个名字才能创建**

  ​	**在function前面套上括号，就以括号开头了，不会被提升，但此时还未执行**

  ​	函数调用：

  ​		函数对象后面加上括号  ： 函数对象（）

```js
(function(){
    let a = 10
    console.log(111)
})();
或
(function(){
    let a = 20
    console.log(222)
}())
```

**注意：格式为（xxx)(yyy) 时，JS解析会认为（xxx)是函数，会调用（xxx)，若（xxx)不是函数，则会报错，所以要注意写分号**

#### 5.8 this

* this

  * 函数在执行时，JS解析器每次都会传递进一个隐含的参数

  * 这个参数就叫做 this

  *  this会指向一个对象

    * **this所指向的对象会根据函数调用方式的不同而不同**
      1. **以函数形式调用时，this指向的是window**
      2. **以方法的形式调用时，this指向的是调用方法的对象**

    ​            ...

  * 通过this可以在方法中引用调用方法的对象

#### 5.9 箭头函数的this

* 箭头函数：

  * ([参数]) => 返回值

* 例子：

  * 无参箭头函数：() => 返回值

  *  一个参数的：a => 返回值

  *  多个参数的：(a, b) => 返回值

  *   只有一个语句的函数：() => 返回值

  *  只返回一个对象的函数：() => ({...})

  * 有多行语句的函数：

    () => {

    ​        ....    
            return 返回值
     }

* **箭头函数没有自己的this，它的this由外层作用域决定**

* **箭头函数的this和它的调用方式无关**

##### 1.在对象外，以函数形式调用

```js
function fn() {
    console.log("fn -->", this)
    //window
}
const fn2 = () => {
    console.log("fn2 -->", this) // 总是window
    //window
}
            // fn() // window
            // fn2() // window
```

##### 2.在对象外，以方法形式调用

```js
const obj = {
    name:"孙悟空",
    fn, // fn:fn
    fn2,
}

obj.fn() // obj
obj.fn2() // window--->箭头函数没有自己的this，它的this由外层作用域决定,箭头函数的this和它的调用方式无关
```

##### 3.在对象外，通过对象.方法调用

```js
const obj = {
    name:"孙悟空",
    fn, // fn:fn
    fn2,
    sayHello(){
        console.log(this.name)
       // 孙悟空
    }
}
obj.sayHello() 
```

##### 4. 在对象中，通过函数调用

```js
const obj = {
    name:"孙悟空",
    fn, // fn:fn
    fn2,
    sayHello(){
        console.log(this.name)
    //注意点1：
       	function t(){
    		console.log("t -->", this)
            // 2. 所以t里this是window
		}
		t()// 1. t是以函数形式调用
   	//注意点2：
        const t2 = () => {
    		console.log("t2 -->", this)
            //2. 所以t2里this是obj
		}
		t2()
        //1. 这是箭头函数，箭头函数的this是他的外层函数
    }
}
obj.sayHello() 
```

#### 5.10 严格模式

JS运行代码的模式有两种：

* 正常模式
  *  默认情况下代码都运行在正常模式中， 在正常模式，语法检查并不严格
  * 它的原则是：能不报错的地方尽量不报错
  *  这种处理方式导致代码的运行性能较差
* 严格模式
  * 在严格模式下，语法检查变得严格
    1. 禁止一些语法
    2.  更容易报错
    3.  提升了性能
* 在开发中，应该尽量使用严格模式，
  * 这样可以将一些隐藏的问题消灭在萌芽阶段， 同时也能提升代码的运行性能

```js
        "use strict" // 全局的严格模式

        let a = 10

        // console.log(a)

        function fn(){
            "use strict" // 函数的严格的模式
        }
```

### 6. 面向对象

